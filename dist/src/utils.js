import{products as e,machines as t,trainIdMap as n,scoringCriteria as r,productTypeHierarchy as o,safetyFactorConfig as i}from"./state.js";export function getToxicityPreference(){const e="true"===localStorage.getItem("productRegister-pdeHidden"),t="true"===localStorage.getItem("productRegister-ld50Hidden");return e&&!t?"ld50":!e&&t||e&&t?"pde":"auto"}export function generateTrainMap(){const t=new Map(n),r={};e.forEach(e=>{if(e.machineIds&&e.machineIds.length>0){const t=a(e.machineIds),n=JSON.stringify(t);r[n]||(r[n]={products:[]}),r[n].products.push(e.id)}}),n.clear();let o=0;t.forEach(e=>{e>o&&(o=e)});const i=Object.keys(r).sort(),s=[];i.forEach(e=>{t.has(e)?n.set(e,t.get(e)):s.push(e)});let c=o+1;s.forEach(e=>{n.set(e,c++)})}function a(e){return[...e].sort((e,t)=>e-t).map(e=>`machine:${e}`)}export function getProductTrainId(e){if(!e.machineIds||0===e.machineIds.length)return"N/A";const t=a(e.machineIds),r=JSON.stringify(t);return n.get(r)||"N/A"}export function getUniqueProductLines(e=[]){const t=["Solids","Semisolid","Liquids"],n=e.map(e=>e&&e.line?String(e.line).trim():null).filter(Boolean).filter(e=>!t.includes(e)),r=[...t,...new Set(n)].sort();return r.includes("Shared")||r.push("Shared"),r}export function getUniqueLinesFromMachines(){const e=t.map(e=>e&&e.line?String(e.line).trim():null).filter(Boolean);return e.length>0?[...new Set(e)].sort():getUniqueProductLines()}export function getTrainsGroupedByLine(){const t=new Set;e.forEach(e=>t.add(e.line&&String(e.line).trim()||"Unassigned"));const r=Array.from(t),o=[];return r.forEach(t=>{const r=e.filter(e=>(e.line&&String(e.line).trim()||"Unassigned")===t&&e.machineIds&&e.machineIds.length>0),i={};r.forEach(e=>{const t=e.productType||"Other";i[t]||(i[t]=[]),i[t].push(e)});const s=[];Object.keys(i).forEach(e=>{const t={};i[e].forEach(n=>{const r=a(n.machineIds),o=JSON.stringify(r);t[o]||(t[o]={key:o,dosageForm:e,consolidatedPath:r,machineIds:Array.from(new Set(n.machineIds)).sort((e,t)=>e-t),products:[]}),t[o].products.push(n)}),Object.values(t).forEach(e=>s.push(e))}),s.sort((e,t)=>e.dosageForm<t.dosageForm?-1:e.dosageForm>t.dosageForm?1:e.key<t.key?-1:e.key>t.key?1:0);let c=1;s.forEach(e=>{e.line=t,e.number=c++,e.id=n.get(e.key)||null}),o.push({line:t,trains:s})}),o}export function getTrainIdToLineNumberMap(){const e=new Map;return getTrainsGroupedByLine().forEach(t=>{t.trains.forEach(t=>{null!==t.id&&void 0!==t.id&&e.set(String(t.id),{line:t.line,number:t.number})})}),e}export function calculateScores(e,t="auto"){const n=(e,t)=>{const n=String(t||"").toLowerCase(),r=e.criteria.find(e=>String(e.text||"").toLowerCase()===n);return r?r.score:e.defaultScore},o=(e,t)=>{const n=parseFloat(t);if(isNaN(n))return e.defaultScore;for(const t of e.criteria){if("greater_exclusive"===t.comparison&&n>t.lowerBound)return t.score;if("less_exclusive"===t.comparison&&n<t.upperBound)return t.score;if("between_inclusive_both"===t.comparison&&n>=t.lowerBound&&n<=t.upperBound)return t.score;if("less_inclusive"===t.comparison&&n<=t.upperBound)return t.score;if("between_exclusive_lower_inclusive_upper"===t.comparison&&n>t.lowerBound&&n<=t.upperBound)return t.score}return e.defaultScore},i=n(r.solubility,e.solubility),a=o(r.therapeuticDose,e.therapeuticDose),s=n(r.cleanability,e.cleanability);let c,u,l;null===e.pde||isNaN(e.pde)||(u=o(r.toxicityPde,e.pde)),null===e.ld50||isNaN(e.ld50)||(l=o(r.toxicityLd50,e.ld50)),c="ld50"===t?void 0!==l?l:void 0!==u?u:1:void 0!==u?u:void 0!==l?l:1;const d=i*a*s*c;return{rpn:d,pdeScore:u,ld50Score:l,solubilityScore:i,therapeuticDoseScore:a,cleanabilityScore:s,rpnRatingText:getRpnRatingText(d)}}export const getRpnRatingText=e=>{const t=r.rpnRating;if(!t||!t.criteria)return"N/A";for(const n of t.criteria){const t=parseFloat(n.min),r=null===n.max||void 0===n.max?1/0:parseFloat(n.max);if(e>=t&&e<=r)return n.rating}return"N/A"};export const getRpnRatingClass=e=>{switch(String(e).toLowerCase()){case"low":return"rpn-low";case"medium":return"rpn-medium";case"high":return"rpn-high";default:return"rpn-default"}};export const debugRpnRating=e=>{console.log("=== DEBUG RPN RATING ==="),console.log("RPN Value:",e),console.log("RPN Config:",r.rpnRating);const t=r.rpnRating;t?t.criteria?(console.log("Available criteria:",t.criteria),t.criteria.forEach((t,n)=>{console.log(`Criteria ${n}:`,{min:t.min,max:t.max,rating:t.rating,minParsed:parseFloat(t.min),maxParsed:parseFloat(t.max),rangeCheck:`${e} >= ${parseFloat(t.min)} && ${e} <= ${parseFloat(t.max)}`,result:e>=parseFloat(t.min)&&e<=parseFloat(t.max)})}),console.log("=== END DEBUG ===")):console.log("ERROR: rpnConfig.criteria is undefined or null"):console.log("ERROR: rpnConfig is undefined or null")};export function getTrainData(){const t={};e.forEach(e=>{if(e.machineIds&&e.machineIds.length>0){const n=a(e.machineIds),r=JSON.stringify(n);if(t[r]){const n=new Set(t[r].machineIds);e.machineIds.forEach(e=>n.add(e)),t[r].machineIds=Array.from(n).sort((e,t)=>e-t)}else t[r]={key:r,consolidatedPath:n,machineIds:e.machineIds,products:[]};t[r].products.push(e)}});const r=Object.values(t).map(e=>({...e,id:n.get(e.key)})).filter(e=>void 0!==e.id);return r.sort((e,t)=>e.id-t.id),0===r.length?[]:(r.forEach(e=>{e.essa=getGroupedTrainSurfaceArea(e.machineIds);const t=e.products.map(e=>e.line).filter(Boolean);if(t.length>0){const n={};t.forEach(e=>{n[e]=(n[e]||0)+1}),e.line=Object.keys(n).reduce((e,t)=>n[e]>n[t]?e:t)}else e.line="Unassigned";let n=null,r=-1;e.products.forEach(e=>{e.activeIngredients.forEach(t=>{const{rpn:o}=calculateScores(t);o>r&&(r=o,n={productName:e.name,ingredientName:t.name,rpn:r,rating:getRpnRatingText(r)})})}),e.worstProductRpn=n;let o=1/0,i=-1;e.products.forEach(e=>{e.activeIngredients.forEach(t=>{t.therapeuticDose<o&&(o=t.therapeuticDose,i=e.id)})}),e.lowestLtd=o,e.lowestLtdProductId=i;const a=e.products.map(e=>{const t=Math.min(...e.activeIngredients.map(t=>1e3*e.batchSizeKg/(t.mdd/1e3)));return{productId:e.id,ratio:t}}).sort((e,t)=>e.ratio-t.ratio);let s,c=-1;if(a.length>0){const e=a[0];if(e.productId===i&&a.length>1){const e=a[1];s=e.ratio,c=e.productId}else s=e.ratio,c=e.productId}else s=1/0;e.minBsMddRatio=s,e.minRatioProductId=c;const u=e.products.reduce((e,t)=>t.batchSizeKg<e.batchSizeKg?t:e,e.products[0]);e.minMbsKg=u.batchSizeKg,e.minMbsProductId=u.id;const l=e.products.flatMap(e=>e.activeIngredients).map(e=>e.pde).filter(e=>null!=e);e.lowestPde=l.length>0?Math.min(...l):null;const d=e.products.flatMap(e=>e.activeIngredients).map(e=>e.ld50).filter(e=>null!=e);e.lowestLd50=d.length>0?Math.min(...d):null,e.assumedSsa=25}),r)}export function getWorstCaseProductType(e){for(const t of o)if(e.includes(t))return t;const t=[...new Set(e)].find(e=>!o.includes(e));return t||"Other"}export function getLargestEssaForLineAndDosageForm(e,t){const n=e.line,r=[...new Set(e.products.map(e=>e.productType||"Other"))],o=t.filter(e=>{const t=e.line,o=[...new Set(e.products.map(e=>e.productType||"Other"))],i=t===n,a=r.some(e=>o.includes(e));return i&&a});return o.length>0?Math.max(...o.map(e=>e.essa)):0}export function getMacoPerSwabForTrain(e,t){const n=(i[getWorstCaseProductType(e.products.map(e=>e.productType))]||i.Other).max,r=e.lowestLtd*e.minBsMddRatio/n,o=10*e.minMbsKg;let a=1/0;null!==e.lowestPde&&(a=e.lowestPde*e.minBsMddRatio);const s=.004*t,c=Math.min(r,o,a,s);return(t>0?c/t:0)*e.assumedSsa}export function populateSelectWithOptions(e,t,n=!1,o=null){if(!e)return;let i;if(e.innerHTML="",e.innerHTML=n?'<option value="all">All</option>':'<option value="" disabled selected>Select...</option>',o)i=[...new Set(o)];else{const e=r[t];if(!e)return;i=[...new Set(e.criteria.map(e=>e.text))]}i.forEach(t=>{e.innerHTML+=`<option value="${t}">${t}</option>`})}export function consolidateMachinesByGroup(e){const n=[],r=new Map;return e.forEach(e=>{const n=t.find(t=>t.id===e);if(!n)return;const o=n.group||`individual_${n.id}`;r.has(o)||r.set(o,{group:n.group||null,machines:[],maxArea:0,representativeMachine:n});const i=r.get(o);i.machines.push(n),n.area>i.maxArea&&(i.maxArea=n.area,i.representativeMachine=n)}),r.forEach((e,t)=>{e.group?n.push({id:`group_${e.group}`,name:`${e.group} (Group)`,group:e.group,area:e.maxArea,stage:e.representativeMachine.stage,isGroup:!0,machineCount:e.machines.length,machines:e.machines}):n.push({...e.representativeMachine,isGroup:!1,machineCount:1,machines:[e.representativeMachine]})}),n}export function getGroupedTrainSurfaceArea(e){return e.reduce((e,n)=>{const r=t.find(e=>e.id===n);return e+(r?r.area:0)},0)}export function getTrainGroupingDetails(e){const n={totalMachines:e.length,consolidatedUnits:e.length,groups:[],individuals:[],totalSurfaceArea:0,worstCaseOptimization:0};return e.forEach(e=>{const r=t.find(t=>t.id===e);r&&(n.totalSurfaceArea+=r.area,n.individuals.push({id:r.id,name:r.name,area:r.area}))}),n.worstCaseOptimization=0,n}export function formatTrainGroupDisplay(e){return e.map(e=>{const n=t.find(t=>t.id===e),r=n?n.name:`Unknown (ID: ${e})`;return`<span class="individual-machine" title="Machine: ${r} - Area: ${(n?n.area:0).toLocaleString()} cm²">${r}</span>`}).join(" → ")}